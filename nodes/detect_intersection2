#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math
import cv2
import numpy as np
import rospy
from cv_bridge import CvBridge
from sensor_msgs.msg import CompressedImage
from nav_msgs.msg import Odometry
from std_msgs.msg import Bool, String
from ultralytics import YOLO


class IntersectionWatcher:
    def __init__(self):
        rospy.init_node("intersection_watcher", anonymous=False)

        # --- Params ---
        self.model_path = rospy.get_param("~model_path", "/home/vcs/catkin_ws/src/koreabot/yolo/best.onnx")
        self.image_topic = rospy.get_param("~image_topic", "/usb_cam/image_raw/compressed")
        self.odom_topic = rospy.get_param("~odom_topic", "/odom")
        self.toggle_topic = rospy.get_param("~toggle_topic", "/detect/lane_toggle")
        self.sign_topic = rospy.get_param("~sign_topic", "/sign_name")
        self.target_sign = rospy.get_param("~target_sign", "parking")   # <<< ป้ายที่ต้องจับ
        self.conf_th = float(rospy.get_param("~conf_th", 0.70))

        self.dist_th = float(rospy.get_param("~dist_th", 0.01))              # 30 cm

        # class id -> name (ปรับตามโมเดลของ Aj)
        self.id2name = rospy.get_param("~id2name", { "0":"left", "1":"parking", "2":"right", "3":"intersection" })
        self.id2name = {int(k): v for k, v in self.id2name.items()}

        # --- Runtime state ---
        self.bridge = CvBridge()
        self.model = YOLO(self.model_path)
        self.have_odom = False
        self.curr_xy = (0.0, 0.0)
        self.armed = False              # True หลังเจอ intersection แล้วรอระยะ
        self.start_xy = None            # ตำแหน่งที่เริ่มจับระยะหลังเจอป้าย
        self.last_fire_time = rospy.Time(0)
        self.cooldown = rospy.Duration(0.5)  # กันสั่นเล็กน้อย

        # --- Pub/Sub ---
        self.pub_toggle = rospy.Publisher(self.toggle_topic, Bool, queue_size=1)
        self.pub_sign = rospy.Publisher(self.sign_topic, String, queue_size=1)

        rospy.Subscriber(self.image_topic, CompressedImage, self.cb_image, queue_size=1)
        rospy.Subscriber(self.odom_topic, Odometry, self.cb_odom, queue_size=20)

        rospy.loginfo("IntersectionWatcher ready. target_sign='%s', dist_th=%.2fm",
                      self.target_sign, self.dist_th)

    # ---------------- Image callback: detect sign ----------------
    def cb_image(self, msg: CompressedImage):
        np_arr = np.frombuffer(msg.data, np.uint8)
        frame = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
        if frame is None:
            return

        # run model
        res = self.model(frame, verbose=False)[0]

        # check each box
        for b in res.boxes:
            conf = float(b.conf.item() if hasattr(b.conf, "item") else b.conf)
            if conf < self.conf_th:
                continue

            cls_id = int(b.cls.item() if hasattr(b.cls, "item") else b.cls)
            cls_name = self.id2name.get(cls_id, "unknown")

            # --- only care about target sign ---
            if cls_name != self.target_sign:
                continue

            # Debounce: อย่า re-arm ซ้อนกัน หากยัง armed อยู่
            if self.armed:
                rospy.logdebug_throttle(1.0, "Already found; ignore further detections.")
                continue

            # Need odom to start measuring distance
            if not self.have_odom:
                rospy.logwarn_throttle(2.0, "Detected '%s' but no /odom yet; waiting...", self.target_sign)
                continue

            # Arm distance tracking
            self.armed = True
            self.start_xy = self.curr_xy
            self.pub_sign.publish(String(self.target_sign))
            rospy.loginfo("Detected '%s' (conf=%.2f). act distance tracking at (%.3f, %.3f).",
                          self.target_sign, conf, self.start_xy[0], self.start_xy[1])

            # วาดกรอบเล็กน้อย (optional)
            x1, y1, x2, y2 = map(int, b.xyxy[0])
            cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 200, 255), 2)
            cv2.putText(frame, f"{cls_name} {conf:.2f}",
                        (x1, max(0, y1-10)), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 200, 255), 2)

            # เจอแล้ว arm ครั้งเดียวพอ
            break

        # แสดงภาพได้ถ้าต้องการ (คอมเมนต์ถ้า headless)
        try:
            cv2.imshow("intersection_watcher", frame)
            cv2.waitKey(1)
        except:
            pass

    # ---------------- Odom callback: track distance ----------------
    def cb_odom(self, msg: Odometry):
        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y
        self.curr_xy = (x, y)
        self.have_odom = True

        # ถ้ายังไม่ armed ไม่ต้องคำนวณ
        if not self.armed or self.start_xy is None:
            return

        # begin วัดระยะทางที่เดินจากตำแหน่ง sign
        dx = x - self.start_xy[0]
        dy = y - self.start_xy[1]
        dist = math.hypot(dx, dy)

        rospy.logdebug_throttle(0.5, "detected: dist=%.3f / %.3f", dist, self.dist_th)

        # ถึงระยะ → ส่ง false ไป /toggle_lane แล้ว reset
        if dist >= self.dist_th and (rospy.Time.now() - self.last_fire_time) > self.cooldown:
            self.pub_toggle.publish(Bool(False))
            self.last_fire_time = rospy.Time.now()
            rospy.loginfo("Distance reached (%.3fm). Published False to %s",
                          dist, self.toggle_topic)

            # send command move robot here
            

            #



            self.armed = False
            self.start_xy = None


if __name__ == "__main__":
    try:
        node = IntersectionWatcher()
        rospy.spin()
    finally:
        try:
            cv2.destroyAllWindows()
        except:
            pass
